<?xml version='1.0' encoding='UTF-8'?>
<project>
  <actions/>
  <description></description>
  <keepDependencies>false</keepDependencies>
  <properties>
    <hudson.model.ParametersDefinitionProperty>
      <parameterDefinitions>
        <hudson.model.StringParameterDefinition>
          <name>DISTRIBUTION</name>
          <description>The Linux distribution of the build server.</description>
          <defaultValue/>
        </hudson.model.StringParameterDefinition>
        <hudson.model.StringParameterDefinition>
          <name>PACKAGE_NAME</name>
          <description/>
          <defaultValue/>
        </hudson.model.StringParameterDefinition>
        <hudson.model.StringParameterDefinition>
          <name>JENKINS_TAR_REPO_LOCATION</name>
          <description>Location which contains uploaded tar information.</description>
          <defaultValue/>
        </hudson.model.StringParameterDefinition>
        <hudson.model.StringParameterDefinition>
          <name>JENKINS_TAR_INSTALL_LOCATION</name>
          <description>Location which contains installed tar information.</description>
          <defaultValue/>
        </hudson.model.StringParameterDefinition>
     </parameterDefinitions>
    </hudson.model.ParametersDefinitionProperty>
  </properties>
  <scm class="hudson.scm.NullSCM"/>
  <assignedNode></assignedNode>
  <canRoam>false</canRoam>
  <disabled>false</disabled>
  <blockBuildWhenDownstreamBuilding>false</blockBuildWhenDownstreamBuilding>
  <blockBuildWhenUpstreamBuilding>false</blockBuildWhenUpstreamBuilding>
  <triggers/>
  <concurrentBuild>false</concurrentBuild>
  <builders>
    <hudson.tasks.Shell>
      <command>#!/bin/bash
#
# This script will retrieve information of a package from a build server. RHEL and UBUNTU distributions are supported
# Inputs:   PACKAGE_NAME    :   names of the packages to be searched. Takes a comma separated value for multiple packages or a single package name
#           DISTRIBUTION    :   Linux distribution of the build server
# Output:   A json file with following data:
#              packageName:         name of the package
#              packageInstalled:    set to true if the package PACKAGE_NAME is installed
#              installedVersion     the installed version of the package PACKAGE_NAME. 'N/A' in case not installed.
#              updateAvailable:     set to true if a new version of the package PACKAGE_NAME is available.
#              updateVersion:       the update version of the package PACKAGE_NAME available.
#                                   If package is installed and there are no updates, 'updateVersion' takes the same value as the
#                                   'installedVersion'. If package is not installed, it takes a value of 'N/A'
#


set +o noclobber # Allow overwrite of files just in case it is set to off

packageInstalled=false
updateAvailable=false
installedVersion="N/A"
updateVersion="N/A"
echo "#### Searching the list of autoport ManagedPackages"
echo "#### List of Packages being searched "$PACKAGE_NAME

echo '['>packageListSingleSlave.json
IFS=, read -a array &lt;&lt;&lt; "$PACKAGE_NAME" # split the csv of PACKAGE_NAME and save it in an array

totalCsvPackages=${#array[@]}
packageCounter=0

echo "#### Iterating through the list of packages"
for packageElement in "${array[@]}"
do
    PACKAGE_NAME=$packageElement
    case $DISTRIBUTION in
        "RHEL")
            # Step 1. Check if package is installed and retrieve its version if installed.
            echo "#### Searching for Package "$PACKAGE_NAME" on "$DISTRIBUTION
            installedVersion=$(rpm -q --queryformat '%{VERSION}:%{ARCH}\n' $PACKAGE_NAME | grep `uname -m`'\|noarch' |awk -F: '{print $1}' )
            if [ ! -z $installedVersion ]
            then
                echo "#### $PACKAGE_NAME is installed. Version is $installedVersion"
                packageInstalled=true
            elif [ -z $installedVersion ]
            then
                echo "#### $PACKAGE_NAME is not installed."
                installedVersion="N/A"
            elif [ $? -eg 127 ]
            then
                echo "#### command not found"
            fi

            #Step 2. If package is installed, check for updates else check for its availability
            if $packageInstalled
            then
                updatePackageOutput=$(yum -q check-update $PACKAGE_NAME)
                if [ $? -eq 100 ]   #if updates are available
                then
                    updatePackageOutput=$(echo $updatePackageOutput) #this strips off whitespaces
                    if [ "${updatePackageOutput}x" != "x" ]
                    then
                        updateVersion=${updatePackageOutput#*\ }
                        updateVersion=${updateVersion%\ *}
                        echo "#### Update for \"$PACKAGE_NAME\" is available with version " $updateVersion
                        updateAvailable=true
                    fi
                    elif [ $? -eq 1 ]
                    then
                        echo "#### $PACKAGE_NAME latest version is installed."
                        updateVersion=$installedVersion
                    fi
                    else # if package is not installed, check for available version
                        # strip the 1st line of the output of yum list
                        availablePackageOutput=$(yum -q list available $PACKAGE_NAME| sed -e '1d')
                    if [ $? -eq 0 ]
                    then
                        availablePackageOutput=$(echo $availablePackageOutput) #this strips off whitespaces
                    if [ "${availablePackageOutput}x" != "x" ]
                    then
                        updateVersion=${availablePackageOutput#*\ }
                        updateVersion=${updateVersion%\ *}
                        updateVersion=${updateVersion#*:}
                        echo "#### Package \"$PACKAGE_NAME\" is available with Version " $updateVersion
                        updateAvailable=true
                    fi
                    elif [ $? -eq 1 ]
                    then
                         echo "#### $PACKAGE_NAME not available"
                    fi
                fi
                if [ $packageCounter -eq $((totalCsvPackages -1)) ]
                then
                    seperator=""
                else
                    seperator=","
                fi
                packageCounter=$((packageCounter +1))

                printf '{"packageName":"%s","packageInstalled":%s,"installedVersion":"%s","updateAvailable":%s, "updateVersion":"%s"
                    }%s' "$PACKAGE_NAME" "$packageInstalled" "$installedVersion" "$updateAvailable" "$updateVersion" "$seperator" >> packageListSingleSlave.json
                ;;
        "UBUNTU")
            # Set variables
            packageInstalled=false
            updateAvailable=false
            installedVersion="N/A"
            updateVersion="N/A"
            lineNumber=1
            echo "#### Searching for Package "$PACKAGE_NAME" on "$DISTRIBUTION
            apt-cache policy $PACKAGE_NAME > singlePackageInformation.txt

            while read i
            do
                 i=$( echo $i | tr -d '[[:space:]]') #trim spaces
                 if [ $lineNumber -eq 2 ]    # Installed information #If package is not found, control will never reach here.
                 then
                    i=${i##*:}  #extract version number, occurs after the colon
                    if [ $i != "(none)" ]
                    then
                        echo "#### $PACKAGE_NAME is installed. Version is $installedVersion"
                        packageInstalled=true
                        installedVersion=$i
                    fi
                    elif [ $lineNumber -eq 3 ] # Update Available information # If package is not found, control will never reach here.
                    then
                        i=${i##*:}  #extract version number, occurs after the colon
                        if [ $i != $installedVersion ]
                        then
                            echo "#### Update for \"$PACKAGE_NAME\" is available with version " $updateVersion
                            updateAvailable=true
                            updateVersion=$i
                        else
                            echo "#### $PACKAGE_NAME latest version is installed."
                            updateVersion=$installedVersion
                        fi
                    fi
                    lineNumber=$((lineNumber+1))
            done &lt; singlePackageInformation.txt

            rm -f singlePackageInformation.txt
            if [ $packageCounter -eq $((totalCsvPackages -1)) ]
            then
                seperator=""
            else
                seperator=","
            fi
            packageCounter=$((packageCounter +1))

            printf '{"packageName":"%s","packageInstalled":%s,"installedVersion":"%s","updateAvailable":%s,"updateVersion":"%s"
                }%s' "$PACKAGE_NAME" "$packageInstalled" "$installedVersion" "$updateAvailable" "$updateVersion" "$seperator" >> packageListSingleSlave.json
        ;;
    esac
done

echo ']'>>packageListSingleSlave.json

# Get the list of all tar packages installed on the build slave.
jenkins_repo_file_name="archive.log"
local_repo_file_name="$JENKINS_TAR_INSTALL_LOCATION/$jenkins_repo_file_name"
installed_package_json=''
if [ $packageCounter -ne $totalCsvPackages -a -f "$local_repo_file_name" ];then
    counter=0
    echo "#### Fetching list of installed tarball source packages..."
    # Next read line by line from the local repo file and prepare the list of tar files installed
    while IFS='' read -r line || [[ -n $line ]]; do
        IFS=', ' read -a package_info &lt;&lt;&lt; "$line"
        echo "#### "${package_info[0]}" is installed. Version is "${package_info[1]}
        package_json="{
            \"packageName\":\"${package_info[0]}\",
            \"summary\":\"${package_info[0]}\",
            \"installedVersion\":\"${package_info[1]}\",
            \"packageInstalled\":\"true\",
            \"updateVersion\":\"N/A\",
            \"updateAvailable\":\"false\",
            \"packageType\":\"${package_info[2]}\"
        }"

        if [ $counter -gt 0 ]; then
            installed_package_json=$(echo $installed_package_json,$package_json)
        else
            installed_package_json=$(echo $package_json)
        fi
        counter=$((counter + 1))
    done &lt; "$local_repo_file_name"
    echo "#### Done: Fetching list of installed source packages!"
    tar_packages=$(echo "[$installed_package_json]")
    echo "$tar_packages" > tarPackages.txt
else
    echo "Skipping Tar packages as all packages are found in OS install"
    echo "[]"> tarPackages.txt
fi

arch_packages=$(cat packageListSingleSlave.json)
echo "$arch_packages" > archivePackages.txt

############################### Python Script for All JSON packages starts:#########################
python_script="#!/usr/bin/python
import sys
import json

# Read json data for archive packages from file.
archive_file=open('archivePackages.txt')
arch_packages=json.load(archive_file)

# Read json data for tar packages from file.
tar_file=open('tarPackages.txt')
tar_packages=json.load(tar_file)

# Merge the yum/apt and tar package list for display
arch_packages.extend(tar_packages)

# Dump data for further processing
print json.dumps(arch_packages)"
echo "$python_script" > final_package_list.py
############################### Python Script for All JSON packages ends:#########################

python final_package_list.py > packageListSingleSlave.json

# Remove temporary files
rm -f archivePackages.txt tarPackages.txt final_package_list.py

echo "#### Completed fetching data for all packages."

</command>
    </hudson.tasks.Shell>
  </builders>
  <publishers>
    <hudson.tasks.ArtifactArchiver>
      <artifacts>*.json</artifacts>
      <latestOnly>false</latestOnly>
      <allowEmptyArchive>false</allowEmptyArchive>
      <onlyIfSuccessful>true</onlyIfSuccessful>
      <defaultExcludes>true</defaultExcludes>
    </hudson.tasks.ArtifactArchiver>
  </publishers>
  <buildWrappers/>
</project>
