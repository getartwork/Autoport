<?xml version='1.0' encoding='UTF-8'?>
<project>
  <actions/>
  <description></description>
  <keepDependencies>false</keepDependencies>
  <properties>
    <hudson.model.ParametersDefinitionProperty>
      <parameterDefinitions>
        <hudson.model.StringParameterDefinition>
          <name>DISTRIBUTION</name>
          <description>The Linus distribution of the build server.</description>
          <defaultValue/>
        </hudson.model.StringParameterDefinition>
		<hudson.model.StringParameterDefinition>
          <name>PACKAGE_NAME</name>
          <description/>
          <defaultValue/>
        </hudson.model.StringParameterDefinition>
	  </parameterDefinitions>
    </hudson.model.ParametersDefinitionProperty>
  </properties>
  <scm class="hudson.scm.NullSCM"/>
  <assignedNode></assignedNode>
  <canRoam>false</canRoam>
  <disabled>false</disabled>
  <blockBuildWhenDownstreamBuilding>false</blockBuildWhenDownstreamBuilding>
  <blockBuildWhenUpstreamBuilding>false</blockBuildWhenUpstreamBuilding>
  <triggers/>
  <concurrentBuild>false</concurrentBuild>
  <builders>
    <hudson.tasks.Shell>
      <command>#!/bin/bash
#
# This script will retrieve information of a package from a build server. RHEL and UBUNTU distributions are supported
# Inputs:   PACKAGE_NAME    :   names of the packages to be searched. Takes a comma separated value for multiple packages or a single package name
#           DISTRIBUTION    :   Linux distribution of the build server
# Output:   A json file with following data:
#              packageName:         name of the package
#              packageInstalled:    set to true if the package PACKAGE_NAME is installed
#              installedVersion     the installed version of the package PACKAGE_NAME. 'N/A' in case not installed.
#              updateAvailable:     set to true if a new version of the package PACKAGE_NAME is available.
#              updateVersion:       the update version of the package PACKAGE_NAME available.
#                                   If package is installed and there are no updates, 'updateVersion' takes the same value as the
#                                   'installedVersion'. If package is not installed, it takes a value of 'N/A'
#


set +o noclobber # Allow overwrite of files just in case it is set to off

packageInstalled=false
updateAvailable=false
installedVersion="N/A"
updateVersion="N/A"
echo "#### Searching the list of autoport ManagedPackages"
echo "#### List of Packages being searched "$PACKAGE_NAME
       
echo '['>packageListSingleSlave.json
IFS=, read -a array &lt;&lt;&lt; "$PACKAGE_NAME" # split the csv of PACKAGE_NAME and save it in an array


totalCsvPackages=${#array[@]} 
packageCounter=0

echo "#### Iterating through the list of packages"
for packageElement in "${array[@]}"
do
	PACKAGE_NAME=$packageElement
	case $DISTRIBUTION in
		"RHEL")
			# Step 1. Check if package is installed and retrieve its version if installed.
			echo "#### Searching for Package "$PACKAGE_NAME" on "$DISTRIBUTION	
			installedVersion=$(rpm -q --queryformat '%{VERSION}:%{ARCH}\n' $PACKAGE_NAME | grep `uname -m`'\|noarch' |awk -F: '{print $1}' )
			if [ $? -eq 0 ]
			then
				echo "#### $PACKAGE_NAME is installed. Version is $installedVersion"
				packageInstalled=true
			elif [ $? -eq 1 ]
			then
				echo "#### $PACKAGE_NAME is not installed."
				installedVersion="N/A"
			elif [ $? -eg 127 ]
			then
				echo "#### command not found"
			fi

			#Step 2. If package is installed, check for updates else check for its availability
			if $packageInstalled
			then
				updatePackageOutput=$(yum -q check-update $PACKAGE_NAME)
				if [ $? -eq 100 ]   #if updates are available
				then
					updatePackageOutput=$(echo $updatePackageOutput) #this strips off whitespaces
					if [ "${updatePackageOutput}x" != "x" ]
					then
						updateVersion=${updatePackageOutput#*\ }
						updateVersion=${updateVersion%\ *}
						echo "#### Update available. Version is" $updateVersion
						updateAvailable=true
					fi
				elif [ $? -eq 1 ]
				then
					echo "#### $PACKAGE_NAME latest version is installed."
					updateVersion=$installedVersion
				fi
			else # if package is not installed, check for available version
				availablePackageOutput=$(yum -q list available $PACKAGE_NAME| sed -e '1d') # strip the 1st line of the output of yum list
				if [ $? -eq 0 ]
				then
					availablePackageOutput=$(echo $availablePackageOutput) #this strips off whitespaces
					if [ "${availablePackageOutput}x" != "x" ]
					then
						updateVersion=${availablePackageOutput#*\ }
						updateVersion=${updateVersion%\ *}
						updateVersion=${updateVersion#*:}
						echo "#### Package available. Version is" $updateVersion
						updateAvailable=true
					fi
				elif [ $? -eq 1 ]
				then
					echo "#### $PACKAGE_NAME not available"
				fi
			fi
		

		if [ $packageCounter -eq $((totalCsvPackages -1)) ]
			then
					seperator=""
			else
					seperator=","
			fi
		packageCounter=$((packageCounter +1))

        printf '{"packageName":"%s","packageInstalled":%s,"installedVersion":"%s","updateAvailable":%s,"updateVersion":"%s"}%s' "$PACKAGE_NAME" "$packageInstalled" "$installedVersion" "$updateAvailable" "$updateVersion" "$seperator" >> packageListSingleSlave.json
		;;
		"UBUNTU")
			
			# Set variables
			packageInstalled=false
			updateAvailable=false
			installedVersion="N/A"
			updateVersion="N/A"
			lineNumber=1
			echo "#### Searching for Package "$PACKAGE_NAME" on "$DISTRIBUTION		
			apt-cache policy $PACKAGE_NAME > singlePackageInformation.txt

			while read i
			do
				i=$( echo $i | tr -d '[[:space:]]') #trim spaces
				if [ $lineNumber -eq 2 ]    # Installed information #If package is not found, control will never reach here.
				then
					i=${i##*:}  #extract version number, occurs after the colon
					if [ $i != "(none)" ]
					then
						packageInstalled=true
						installedVersion=$i
					fi
				elif [ $lineNumber -eq 3 ] # Update Available information # If package is not found, control will never reach here.
				then
					i=${i##*:}  #extract version number, occurs after the colon
					if [ $i != $installedVersion ]
					then
						updateAvailable=true
						updateVersion=$i
					else
						updateVersion=$installedVersion
					fi
				fi
				lineNumber=$((lineNumber+1))
			done &lt; singlePackageInformation.txt

			rm -f singlePackageInformation.txt
			
			if [ $packageCounter -eq $((totalCsvPackages -1)) ]
			then
					seperator=""
			else
					seperator=","
			fi
			packageCounter=$((packageCounter +1))


            printf '{"packageName":"%s","packageInstalled":%s,"installedVersion":"%s","updateAvailable":%s,"updateVersion":"%s"}%s' "$PACKAGE_NAME" "$packageInstalled" "$installedVersion" "$updateAvailable" "$updateVersion" "$seperator" >> packageListSingleSlave.json
    ;;
	esac
	
done

echo "#### Completed fetching data for all packages."
echo ']'>>packageListSingleSlave.json
</command>
    </hudson.tasks.Shell>
  </builders>
  <publishers>
    <hudson.tasks.ArtifactArchiver>
      <artifacts>*.json</artifacts>
      <latestOnly>false</latestOnly>
      <allowEmptyArchive>false</allowEmptyArchive>
      <onlyIfSuccessful>true</onlyIfSuccessful>
      <defaultExcludes>true</defaultExcludes>
    </hudson.tasks.ArtifactArchiver>
  </publishers>
  <buildWrappers/>
</project>
